---
layout: post
title: How Was Galaxy Fox Token Exploited?
date: 2024-05-11 11:46:00
description: Learn how Galaxy Fox Token was exploited, resulting in a loss of assets worth $330,000.
tags: access-control galaxy-fox-token
categories: blockchain-hacks
thumbnail: assets/img/galaxy-fox-token-exploit.png
related_posts: true
toc:
  sidebar: left
---

## TL;DR

On May 10, 2024, the Galaxy Fox token was exploited on the Ethereum Mainnet due to a smart contract vulnerability, which resulted in a loss of over 108 ETH, worth approximately $330,000.

## Introduction to Galaxy Fox

Galaxy Fox is a web3 platform that features their native token, captivating NFTs, a staking platform, and thrilling play-to-earn gaming ecosystem.

## Vulnerability Assessment

The root cause of the exploit is a lack of regulated access control.

### Steps

**Step 1:**

We attempt to analyse [the attack transaction](https://etherscan.io/tx/0x12fe79f1de8aed0ba947cec4dce5d33368d649903cb45a5d3e915cc459e751fc) executed by [the exploiter](https://etherscan.io/address/0xfce19f8f823759b5867ef9a5055a376f20c5e454).

**Step 2:**

The [vulnerable and exploited contract](https://etherscan.io/address/0x11a4a5733237082a6c08772927ce0a2b5f8a86b6) was unverified, so we attempted [to decompile it](https://app.dedaub.com/ethereum/address/0x11a4a5733237082a6c08772927ce0a2b5f8a86b6/decompiled). The setMerkleRoot function was set to a public visibility access specifier and lacked enough access control to allow anyone to change the merkel roots.

```solidity
function setMerkleRoot(bytes32 _merkleRoot) public payable {
  require(msg.data.length - 4 >= 32);
  _merkleRoot = _merkleRoot;
}
```

**Step 3:**

This allowed them to invoke a call to the claim function to falsely claim and withdraw 108 ETH worth of funds from the contract.

```solidity
function claim(address to, uint256 amount, bytes32[] proof) public payable {
  require(msg.data.length - 4 >= 96);
  require(proof <= uint64.max);
  require(4 + proof + 31 < msg.data.length);
  require(proof.length <= uint64.max);
  require(4 + proof + (proof.length << 5) + 32 <= msg.data.length);
  require(_claimStart > 0, Error("GfoxClaim: Not started"));
  require(block.timestamp >= _claimStart, Error("GfoxClaim: Not started"));
  require(amount > _claimedAmount[to], Error("GfoxClaim: Already claimed"));
  v0 = new uint256[](proof.length);
  CALLDATACOPY(v0.data, proof.data, proof.length << 5);
  v0[proof.length] = 0;
  v1 = v2 = keccak256(bytes20(to << 96), amount);
  v3 = v4 = 0;
  while (v3 < v0.length) {
    require(v3 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice
    v1 = v5 = 0x9c0(v0[v3], v1);
    v3 += 1;
  }
  require(v1 == _merkleRoot, Error("GfoxClaim: Invalid proof"));
  v6 = 0x718(amount);
  v7 = _SafeSub(v6, _claimedAmount[to]);
  v8 = _SafeAdd(_claimedAmount[to], v7);
  _claimedAmount[to] = v8;
  emit Claimed(to, v7, amount);
  0x7d1(v7, to, address(0x8f1cece048cade6b8a05dfa2f90ee4025f4f2662));
}
```

The flashbot private transactions sent by the [actual attacker](https://etherscan.io/address/0x000000000004c825e42d37eed998ab91bbad7883) were [front-run](https://etherscan.io/tx/0x605ec9f8e739450bdc84240c975c119570581fc368cf4302c8f8e5646ffe9454) by the [original attacker](https://etherscan.io/address/0xfce19f8f823759b5867ef9a5055a376f20c5e454), who was able to steal the assets.

**Step 4:**

The [original attacker](https://etherscan.io/address/0xfce19f8f823759b5867ef9a5055a376f20c5e454) was followed by yet another [copycat attacker](https://etherscan.io/address/0x14b362d2e38250604f21a334d71c13e2ed478467), who was also able to successfully execute the said attack to take away the remaining funds. The original attacker [approved 99.79 ETH](https://etherscan.io/tx/0x5d6b4319f8f9bb080a44131ac34101d3989602de9d8f111c57ab393780f94c1f) or $289,221 for his trade and has a hold of 9.03 ETH at [this address](https://debank.com/profile/0xfce19f8f823759b5867ef9a5055a376f20c5e454/stream), which is worth roughly $26,167.

**Step 5:**

The [copycat attacker](https://etherscan.io/address/0x14b362d2e38250604f21a334d71c13e2ed478467) took away approximately [27.8 million GFOX tokens](https://app.blocksec.com/explorer/tx/eth/0x6a3d91fbd0a865a56c4efa7c540f28adcf7b569df44c9d50e1f86ab51b177405) and [swapped them](https://etherscan.io/tx/0xfbccd51ed0e51e8f0e9b36396d62dc7e003230972bb9fed6872c5d1bcdf0a958) for 2.32 ETH, which were worth roughly $7029. As of this writing, the [wallet of the copycat attacker](https://debank.com/profile/0x14B362d2E38250604F21A334D71C13E2eD478467) has a hold of 2.17 ETH, which is approximately $6,294. This attacker has also already laundered 2 ETH, amounting to roughly $5,800 to Tornado Cash, as seen in [these](https://etherscan.io/tx/0xade6c3f983a72bef30cb5fbf15de4faf046873339b3f07456a05074b036fba75) and [other](https://etherscan.io/tx/0x3e35fe8caf95ef7afb66212005758246f1ebb17e8fa6a3031417913a519f3d80) transactions.

## Solution

To address the vulnerability exploited in the Galaxy Fox token incident, a comprehensive revision of the smart contract’s access control mechanisms is essential. The primary flaw was the public accessibility of the setMerkleRoot function, which should have been restricted to only authorized addresses. Implementing proper access control can be effectively achieved by utilizing modifiers in the Solidity programming language.

One effective solution is to introduce a modifier that checks whether the message sender, or `msg.sender`, is an authorized user. This can be done by maintaining a list of authorized addresses of the owner in a mapping. The owner could be a state variable set to the deployer’s address, or alternatively, it could be a role-based system where multiple addresses are authorized to perform certain actions. This modifier is then applied to the `setMerkleRoot` function, ensuring that only an authorized user can execute it.

Beyond simple owner-based controls, a more robust and flexible access control system can be implemented using role-based access control (RBAC). This system can manage different levels of permissions for different types of actions within the contract. The OpenZeppelin library provides well-tested contracts for such purposes, including AccessControl, which allows for multiple roles to be created and managed. Each role can be assigned specific permissions, and multiple accounts can be granted or revoked roles dynamically.

Implementing these changes would significantly enhance the security of the contract by restricting critical functionalities to only those addresses that are explicitly authorized. Moreover, it is crucial to undergo thorough audits and extensive testing on testnets before deploying the contract on the mainnet. These audits should be conducted by independent security experts to ensure that no vulnerabilities remain.

_This article was [originally published](https://medium.com/p/c0860520cdc2) by Pukar Acharya elsewhere._
